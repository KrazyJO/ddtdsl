/*
 * generated by Xtext
 */
package de.wbg.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import de.wbg.dTDSL.DTDSL
import de.wbg.dTDSL.Choice
import de.wbg.dTDSL.Many
import de.wbg.dTDSL.Keyword
import de.wbg.dTDSL.ObjectDescription
import de.wbg.NodeGen
import de.wbg.dTDSL.ObjectAttribute
import de.wbg.dTDSL.ObjectNext

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class DTDSLGenerator implements IGenerator {
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))

		var nodeGen = new NodeGen()

		fsa.generateFile('de/wbg/dtdsl/Node.java', nodeGen.generateNode)

		for (model: resource.allContents.toIterable.filter(DTDSL))
		{
			fsa.generateFile('de/wbg/dtdsl/' + model.parserName + '.java', 
				if (model.type == "javaObject") 
				{
					
					model.compile();
				}
				else if (model.type == "string")
				{
					//TODO compileString
				}			
			);	
		}
	}
	
	def CharSequence compile(DTDSL model)
	{
		var ret = ''''''
		
		ret += '''
		package de.wbg.dtdsl;
		
		import java.lang.reflect.Field;
		
		class «model.parserName.toFirstUpper» {
			
			private Node headNode;
			private Node actualNode;
			
			public «model.parserName.toFirstUpper»()
			{
				this.headNode = new Node();
				this.headNode.setKey(false);
				this.headNode.setName("HeadNode");
				this.headNode.setValue("none");
				this.actualNode = this.headNode;
			}
			
			public Node parse(Object o)
			{
				//model.start
				parse«model.start.begin.name»(o, actualNode);
				
				return headNode;
			}
			
		'''
		for (d: model.objDescription)
		{
			if (d instanceof ObjectDescription) 
			{
				ret+=
				'''	private void parse«d.name»(Object o, Node n)
	{
		Node node = new Node();
		node.setParent(actualNode);
		n.getChildren().add(node);
		
		'''for (i: d.description)
			{
				if (i instanceof ObjectAttribute) {ret += i.compile}
				if (i instanceof ObjectNext) {ret += i.compile}
						
			}
			ret+= '''		//actualNode.getChildren().add(node);
		actualNode = n;
	}
			
			'''	
			}
			
			
		}
		
		ret += '''
		}
		
		'''
		
		ret
	}
	
	def CharSequence compile(ObjectAttribute a)
	{
		var ret = '''		//Attribute
		'''
		
		if (a.inner == null) {
			ret += '''		//inner == null
		//«a.types» «a.attributes» as «a.keyword.name»;
		«if (a.keyword.name == 'Key')
		{
			'''try {
	Field f = o.getClass().getDeclaredField("«a.attributes»"); //NoSuchFieldException
	f.setAccessible(true);
	«a.types» iWantThis = («a.types») f.get(o); //IllegalAccessException

	node.setName("«a.attributes»");
	node.setValue(String.valueOf(iWantThis));
	node.setKey(true);
} 
catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e)
{
	e.printStackTrace();
}'''
		}
		else if (a.keyword.name == 'Value')
		{
			'''try {
	Node valueNode = new Node();
	valueNode.setKey(false);

	Field f = o.getClass().getDeclaredField("«a.attributes»"); //NoSuchFieldException
	f.setAccessible(true);
	«a.types» iWantThis = («a.types») f.get(o); //IllegalAccessException

	valueNode.setName("«a.attributes»");
	valueNode.setValue(String.valueOf(iWantThis));

	valueNode.setParent(node);
	node.getChildren().add(valueNode);
}
catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e)
{
	e.printStackTrace();
}
'''


		}»
			'''
		} else {
			ret += '''		//inner == «a.inner.name»
			'''
		}
		
		ret += '''
		
		'''
		
		ret
	}
	
	def CharSequence compile(ObjectNext n)
	{
		'''		//Next: «n.attribute.code»
		'''	
	}
}
